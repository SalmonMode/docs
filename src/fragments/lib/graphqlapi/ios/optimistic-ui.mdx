Implementing optimistic UI with GraphQL API category allows CRUD operations to be rendered immediately on the UI before the request roundtrip has completed, and allows you to rollback changes on the UI when API calls are unsuccessful.

In the following example, we'll create a list view that optimistically renders newly created items, updates and deletes.

<Callout>

For more on the Amplify GraphQL API, see the [API documentation](https://docs.amplify.aws/lib/graphqlapi/getting-started/q/platform/ios/).

</Callout>

To get started, run the following command in an existing Amplify project with a iOS frontend:

```bash
# Select default configuration
amplify add api              
```

When prompted, use the following schema:

```graphql
type RealEstateProperty @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  address: String
}
```
The schema file can also be found under `amplify/backend/api/[name of project]/schema.graphql`.
Save the schema and run `amplify push` to deploy the changes. For the purposes of this guide, we'll build a Real Estate Property listing application.

Run `amplify codegen models`

Next, at the root of your project 

```swift

import Amplify

// Create a client
Amplify.add(AWSAPIPlugin(AmplifyModels()))
Amplify.API.configure()
```

<Callout>

For the complete working example see the [Complete Example](#complete-example) below.

</Callout>

## How to use a Swift Actor to control access to list items

A Swift actor helps serialize access to its underlying properties. In this example, we provide updates to the list through a Combine publisher for the view to render, while its methods maintain the state of the list before it is finalized.

- create then rollback if needed
- update then rollback if needed
- delete then rollback if needed

By providing these methods through an actor object, the underlying list will be accessed serially so that the entire operation can be rolled back if needed.


<Callout>

For more information on Swift actors. 

</Callout>


To create an actor object that allows optimistic UI updates, create a new file and add the following code. 

<BlockSwitcher>
<Block name="Swift">

```swift
import Amplify
import SwiftUI
import Combine

actor RealEstatePropertyList {
    
    private var properties: [RealEstateProperty?] = [] {
        didSet {
            subject.send(properties.compactMap { $0 })
        }
    }
    
    private let subject = PassthroughSubject<[RealEstateProperty], Never>()
    var publisher: AnyPublisher<[RealEstateProperty], Never> {
        subject.eraseToAnyPublisher()
    }
    
    func listProperties() async throws {
        let result = try await Amplify.API.query(request: .list(RealEstateProperty.self))
        guard case .success(let propertyList) = result else {
            print("Failed with error: ", result)
            return
        }
        properties = propertyList.elements
    }
}
``` 

</Block>
</BlockSwitcher>

Calling the listProperties method will perform a query with GraphQL API and store the results in the `properties` property. When this property is set, the list is send back to the subscribers through the passthrough subject. On your UI, create a view model and subscribe to updates:

<BlockSwitcher>
<Block name="Swift">

```swift
class RealEstatePropertyContainerViewModel: ObservableObject {
    @Published var properties: [RealEstateProperty] = []
    var sink: AnyCancellable?
    
    var propertyList = RealEstatePropertyList()
    init() {
        Task {
            sink = await propertyList.publisher
                .receive(on: DispatchQueue.main)
                .sink { properties in
                    print("Updating property list")
                    self.properties = properties
            }
        }
    }
    
    func loadList() {
        Task {
            try? await propertyList.listProperties()
        }
    }
}

struct RealEstatePropertyContainerView: View {
    @StateObject var vm = RealEstatePropertyContainerViewModel()
    @State private var propertyName: String = ""
    
    var body: some View {
        Text("Hello")
    }
}
``` 

</Block>
</BlockSwitcher>

## Optimistically rendering a newly created record

To optimistically render a newly created record returned from the GraphQL API, add a method to the actor RealEstatePropertyList:

<BlockSwitcher>
<Block name="Swift">

```swift
func createProperty(name: String, address: String? = nil) {
  let property = RealEstateProperty(name: name, address: address)
  // Optimistically send the newly created property, for the UI to render.
  properties.append(property)
  
  Task {
      do {
          // Create the property record
          let result = try await Amplify.API.mutate(request: .create(property))
          guard case .failure(let graphQLResponse) = result else {
              return
          }
          print("Failed with error: ", graphQLResponse)
          // Remove the newly created property
          properties.removeLast()
      } catch {
          print("Failed with error: ", error)
          // Remove the newly created property
          properties.removeLast()
      }
  }
}
``` 

</Block>
</BlockSwitcher>

## Optimistically rendering a record update

To optimistically render updates on a single item

<BlockSwitcher>
<Block name="Swift">

```swift
func updateProperty(_ property: RealEstateProperty) async {
    guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
        print("No property to update")
        return
    }

    // Optimistically update the property, for the UI to render.
    let rollbackProperty = properties[index]
    properties[index] = property
    
    do {
        // Update the property record
        let result = try await Amplify.API.mutate(request: .update(property))
        guard case .failure(let graphQLResponse) = result else {
            return
        }
        print("Failed with error: ", graphQLResponse)
        properties[index] = rollbackProperty
    } catch {
        print("Failed with error: ", error)
        properties[index] = rollbackProperty
    }
}
``` 

</Block>

</BlockSwitcher>

## Optimistically render deleting a record

To optimistically render a GraphQL API delete

<BlockSwitcher>
<Block name="Swift">

```swift
func deleteProperty(_ property: RealEstateProperty) async {
  guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
      print("No property to remove")
      return
  }
  
  // Optimistically remove the property, for the UI to render.
  let rollbackProperty = properties[index]
  properties[index] = nil
  
  do {
      // Delete the property record
      let result = try await Amplify.API.mutate(request: .delete(property))
      switch result {
      case .success:
          // Finalize the removal
          properties.remove(at: index)
      case .failure(let graphQLResponse):
          print("Failed with error: ", graphQLResponse)
          // Undo the removal
          properties[index] = rollbackProperty
      }
      
  } catch {
      print("Failed with error: ", error)
      // Undo the removal
      properties[index] = rollbackProperty
  }
}
``` 

</Block>

</BlockSwitcher>

## Complete example

<BlockSwitcher>
<Block name="Main">

```swift
extension RealEstateProperty: Identifiable {
    
}
```

</Block>

<Block name="Actor">

```swift
actor RealEstatePropertyList {
    
    private var properties: [RealEstateProperty?] = [] {
        didSet {
            subject.send(properties.compactMap { $0 })
        }
    }
    
    private let subject = PassthroughSubject<[RealEstateProperty], Never>()
    var publisher: AnyPublisher<[RealEstateProperty], Never> {
        subject.eraseToAnyPublisher()
    }
    
    func listProperties() async throws {
        let result = try await Amplify.API.query(request: .list(RealEstateProperty.self))
        guard case .success(let propertyList) = result else {
            print("Failed with error: ", result)
            return
        }
        properties = propertyList.elements
    }
    
    func createProperty(name: String, address: String? = nil) {
        let property = RealEstateProperty(name: name, address: address)
        // Optimistically send the newly created property, for the UI to render.
        properties.append(property)
        
        Task {
            do {
                // Create the property record
                let result = try await Amplify.API.mutate(request: .create(property))
                guard case .failure(let graphQLResponse) = result else {
                    return
                }
                print("Failed with error: ", graphQLResponse)
                // Remove the newly created property
                properties.removeLast()
            } catch {
                print("Failed with error: ", error)
                // Remove the newly created property
                properties.removeLast()
            }
        }
    }
    func updateProperty(_ property: RealEstateProperty) async {
        guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
            print("No property to update")
            return
        }

        // Optimistically update the property, for the UI to render.
        let rollbackProperty = properties[index]
        properties[index] = property
        
        do {
            // Update the property record
            let result = try await Amplify.API.mutate(request: .update(property))
            guard case .failure(let graphQLResponse) = result else {
                return
            }
            print("Failed with error: ", graphQLResponse)
            properties[index] = rollbackProperty
        } catch {
            print("Failed with error: ", error)
            properties[index] = rollbackProperty
        }
    }
        
    func deleteProperty(_ property: RealEstateProperty) async {
        guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
            print("No property to remove")
            return
        }
        
        // Optimistically remove the property, for the UI to render.
        let rollbackProperty = properties[index]
        properties[index] = nil
        
        do {
            // Delete the property record
            let result = try await Amplify.API.mutate(request: .delete(property))
            switch result {
            case .success:
                // Finalize the removal
                properties.remove(at: index)
            case .failure(let graphQLResponse):
                print("Failed with error: ", graphQLResponse)
                // Undo the removal
                properties[index] = rollbackProperty
            }
            
        } catch {
            print("Failed with error: ", error)
            // Undo the removal
            properties[index] = rollbackProperty
        }
    }
}

```

</Block>

<Block name="View">

```swift
class RealEstatePropertyContainerViewModel: ObservableObject {
    @Published var properties: [RealEstateProperty] = []
    var sink: AnyCancellable?
    
    var propertyList = RealEstatePropertyList()
    init() {
        Task {
            sink = await propertyList.publisher
                .receive(on: DispatchQueue.main)
                .sink { properties in
                    print("Updating property list")
                    self.properties = properties
            }
        }
    }
    
    func loadList() {
        Task {
            try? await propertyList.listProperties()
        }
    }
    func createPropertyButtonTapped(name: String) {
        Task {
            await propertyList.createProperty(name: name)
        }
    }
    
    func updatePropertyButtonTapped(_ property: RealEstateProperty) {
        Task {
            await propertyList.updateProperty(property)
        }
    }

    func deletePropertyButtonTapped(_ property: RealEstateProperty) {
        Task {
            await propertyList.deleteProperty(property)
        }
    }
}

struct RealEstatePropertyContainerView: View {
    @StateObject var vm = RealEstatePropertyContainerViewModel()
    @State private var propertyName: String = ""
    
    var body: some View {
        NavigationView {
            VStack {
                ScrollView {
                    LazyVStack(alignment: .leading) {
                        ForEach($vm.properties) { $property in
                            HStack {
                                TextField("Update property name", text: $property.name)
                                    .textFieldStyle(RoundedBorderTextFieldStyle())
                                    .multilineTextAlignment(.center)
                                Button("Update") {
                                    vm.updatePropertyButtonTapped(property)
                                }
                                Button {
                                    vm.deletePropertyButtonTapped(property)
                                } label: {
                                    Image(systemName: "xmark")
                                                .foregroundColor(.red)
                                }

                            }.padding(.horizontal)
                        }
                    }
                }.refreshable {
                    vm.loadList()
                }
                TextField("New property name", text: $propertyName)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .multilineTextAlignment(.center)
                
                Button("Save") {
                    vm.createPropertyButtonTapped(name: propertyName)
                    self.propertyName = ""
                }
                .buttonStyle(TappedButtonStyle())
            }.task {
                vm.loadList()
            }
            .navigationBarItems(trailing: SignOutButton())
        }
    }
}

struct RealEstatePropertyContainerView_Previews: PreviewProvider {
    static var previews: some View {
        RealEstatePropertyContainerView()
    }
}
```

</Block>

</BlockSwitcher>